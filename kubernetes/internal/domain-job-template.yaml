# Copyright 2017, 2018, Oracle Corporation and/or its affiliates.  All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at http://oss.oracle.com/licenses/upl.
apiVersion: v1
kind: ConfigMap
metadata:
  name: domain-%DOMAIN_UID%-scripts
  namespace: %NAMESPACE%
  labels:
    weblogic.domainUID: %DOMAIN_UID%
data:
  utility.sh: |-
    #!/bin/bash
    #

    #
    # Report an error and fail the job
    # $1 - text of error
    function fail {
      echo ERROR: $1
      exit 1
    }

    #
    # Create a folder
    # $1 - path of folder to create
    function createFolder {
      mkdir -m 777 -p $1
      if [ ! -d $1 ]; then
        fail "Unable to create folder $1"
      fi
    }

    #
    # Check a file exists
    # $1 - path of file to check
    function checkFileExists {
      if [ ! -f $1 ]; then
        fail "The file $1 does not exist"
      fi
    }

  create-domain-job.sh: |-
    #!/bin/bash
    #

    # Include common utility functions
    source /u01/weblogic/utility.sh

    # Verify the script to create the domain exists
    script='%CREATE_DOMAIN_SCRIPT%'
    if [ -f $script ]; then
      echo The domain will be created using the script $script
    else
      fail "Could not locate the domain creation script ${script}"
    fi

    # Validate the domain secrets exist before proceeding.
    if [ ! -f /weblogic-operator/secrets/username ]; then
      fail "The domain secret /weblogic-operator/secrets/username was not found"
    fi
    if [ ! -f /weblogic-operator/secrets/password ]; then
      fail "The domain secret /weblogic-operator/secrets/password was not found"
    fi

    # Do not proceed if the domain already exists
    domainFolder=${SHARED_PATH}/domain/%DOMAIN_NAME%
    if [ -d ${domainFolder} ]; then
      fail "The create domain job will not overwrite an existing domain. The domain folder ${domainFolder} already exists"
    fi

    # Create the base folders
    createFolder ${SHARED_PATH}/domain
    createFolder ${SHARED_PATH}/applications
    createFolder ${SHARED_PATH}/logs
    createFolder ${SHARED_PATH}/stores

    # Execute the script to create the domain
    source $script

  read-domain-secret.py: |-
    #
    # +++ Start of common code for reading domain secrets

    # Read username secret
    file = open('/weblogic-operator/secrets/username', 'r')
    admin_username = file.read()
    file.close()

    # Read password secret
    file = open('/weblogic-operator/secrets/password', 'r')
    admin_password = file.read()
    file.close()

    # +++ End of common code for reading domain secrets
    #

  create-domain-script.sh: |-
    #!/bin/bash
    #

    # Include common utility functions
    source /u01/weblogic/utility.sh

    export DOMAIN_HOME=${SHARED_PATH}/domain/%DOMAIN_NAME%

    function createCommonNodeMgrHome() {

      # Create nodemanager home for the server
      nmdir=${DOMAIN_HOME}/nodemgr_home
      createFolder ${nmdir}
      prop=${nmdir}/nodemanager.properties
      cp ${DOMAIN_HOME}/nodemanager/nodemanager.properties ${nmdir}
    }

    # Function to create script for starting a server
    # \$1 - Domain UID
    # \$2 - Server Name
    function createCommonStartScripts() {

      nmdir=${DOMAIN_HOME}/nodemgr_home
      scriptFile=${nmdir}/startServer.sh
      pyFile=${nmdir}/start-server.py

      # Create a script that starts the node manager, then uses wlst to connect
      # to the nodemanager and start the server.
      # The script and 'EOF' on the following lines must not be indented!
      cat << EOF > ${scriptFile}
    #!/bin/bash

    domain_uid=\$1
    server_name=\$2
    as_name=\$3
    as_port=\$4
    as_hostname=\$1-\$3

    echo "debug arguments are \$1 \$2 \$3 \$4"

    nmProp="/u01/nodemanager/nodemanager.properties"

    # TODO: parameterize shared home and domain name
    export DOMAIN_HOME=/shared/domain/%DOMAIN_NAME%

    #
    # Create a folder
    # \$1 - path of folder to create
    function createFolder {
      mkdir -m 777 -p \$1
      if [ ! -d \$1 ]; then
        fail "Unable to create folder \$1"
      fi
    }

    # Function to create server specific scripts and properties (e.g startup.properties, etc)
    # \$1 - Domain UID
    # \$2 - Server Name
    # \$3 - Admin Server Hostname (only passed for managed servers)
    # \$4 - Admin Server port (only passed for managed servers)
    function createServerScriptsProperties() {

      # Create nodemanager home for the server
      srvr_nmdir=/u01/nodemanager
      createFolder \${srvr_nmdir}
      cp ${DOMAIN_HOME}/nodemanager/nodemanager.domains \${srvr_nmdir}
      cp ${DOMAIN_HOME}/bin/startNodeManager.sh \${srvr_nmdir}

      # Edit the start nodemanager script to use the home for the server
      sed -i -e "s:/shared/domain/base_domain/nodemanager:/u01/nodemanager:g" ${srvr_nmdir}/startNodeManager.sh

      # Create startup.properties file
      datadir=\${DOMAIN_HOME}/servers/\$2/data/nodemanager
      nmdir=\${DOMAIN_HOME}/nodemgr_home
      stateFile=\${datadir}/\$2.state
      startProp=\${datadir}/startup.properties
      if [ -f "\$startProp" ]; then
        echo "startup.properties already exists"
        return 0
      fi

      createFolder \${datadir}
      echo "# Server startup properties" > \${startProp}
      echo "AutoRestart=true" >> \${startProp}
      if [ -n "\$3" ]; then
        echo "AdminURL=http\://\$3\:\$4" >> \${startProp}
      fi
      echo "RestartMax=2" >> \${startProp}
      echo "RotateLogOnStartup=false" >> \${startProp}
      echo "RotationType=bySize" >> \${startProp}
      echo "RotationTimeStart=00\:00" >> \${startProp}
      echo "RotatedFileCount=100" >> \${startProp}
      echo "RestartDelaySeconds=0" >> \${startProp}
      echo "FileSizeKB=5000" >> \${startProp}
      echo "FileTimeSpanFactor=3600000" >> \${startProp}
      echo "RestartInterval=3600" >> \${startProp}
      echo "NumberOfFilesLimited=true" >> \${startProp}
      echo "FileTimeSpan=24" >> \${startProp}
      echo "NMHostName=\$1-\$2" >> \${startProp}
    }

    # Check for stale state file and remove if found"
    if [ -f \${stateFile} ]; then
      echo "Removing stale file \${stateFile}"
      rm \${stateFile}
    fi

    # Create nodemanager home directory that is local to the k8s node
    mkdir -p /u01/nodemanager
    cp \${DOMAIN_HOME}/nodemanager/* /u01/nodemanager/
    cp \${DOMAIN_HOME}/nodemgr_home/nodemanager.properties /u01/nodemanager

    # Edit the nodemanager properties file to use the home for the server
    sed -i -e "s:DomainsFile=.*:DomainsFile=/u01/nodemanager/nodemanager.domains:g" /u01/nodemanager/nodemanager.properties
    sed -i -e "s:NodeManagerHome=.*:NodeManagerHome=/u01/nodemanager:g" /u01/nodemanager/nodemanager.properties
    sed -i -e "s:ListenAddress=.*:ListenAddress=\$1-\$2:g" /u01/nodemanager/nodemanager.properties
    sed -i -e "s:LogFile=.*:LogFile=/shared/logs/nodemanager-\$2.log:g" /u01/nodemanager/nodemanager.properties

    export JAVA_PROPERTIES="-DLogFile=/shared/logs/nodemanager-\$server_name.log -DNodeManagerHome=/u01/nodemanager"
    export NODEMGR_HOME="/u01/nodemanager"


    # Create startup.properties
    echo "Create startup.properties"
    if [ -n "\$3" ]; then
      echo "this is managed server"
      createServerScriptsProperties \$domain_uid \$server_name \$as_hostname \$as_port
    else
      echo "this is admin server"
      createServerScriptsProperties \$domain_uid \$server_name
    fi

    echo "Start the nodemanager"
    . \${NODEMGR_HOME}/startNodeManager.sh &

    echo "Allow the nodemanager some time to start before attempting to connect"
    sleep 15
    echo "Finished waiting for the nodemanager to start"

    echo "Update JVM arguments"
    echo "Arguments=\${USER_MEM_ARGS} -XX\:+UnlockExperimentalVMOptions -XX\:+UseCGroupMemoryLimitForHeap \${JAVA_OPTIONS}" >> \${startProp}

    admin_server_t3_url=
    if [ -n "\$3" ]; then
      admin_server_t3_url=t3://\$domain_uid-\$as_name:\$as_port
    fi

    echo "Start the server"
    wlst.sh -skipWLSModuleScanning ${pyFile} \$domain_uid \$server_name \$admin_server_t3_url

    echo "Wait indefinitely so that the Kubernetes pod does not exit and try to restart"
    while true; do sleep 60; done
    EOF

      checkFileExists ${scriptFile}
      chmod +x ${scriptFile}

      # Create a python script to execute the wlst commands.
      # The script and 'EOF' on the following lines must not be indented!
      echo "import sys;" > ${pyFile}
      cat /u01/weblogic/read-domain-secret.py >> ${pyFile}
      cat << EOF >> ${pyFile}

    domain_uid = sys.argv[1]
    server_name = sys.argv[2]
    if (len(sys.argv) == 4):
      admin_server_url = sys.argv[3]
    else:
      admin_server_url = None

    domain_path= "${DOMAIN_HOME}"

    print 'admin username is %s' % admin_username
    print 'domain path is %s' % domain_path
    print 'server name is %s' % server_name
    print 'admin server url is %s' % admin_server_url

    # Encrypt the admin username and password
    adminUsernameEncrypted=encrypt(admin_username, domain_path)
    adminPasswordEncrypted=encrypt(admin_password, domain_path)

    print 'Create boot.properties files for this server'

    # Define the folder path
    secdir='%s/servers/%s/security' % (domain_path, server_name)

    # Create the security folder (if it does not already exist)
    try:
      os.makedirs(secdir)
    except OSError:
      if not os.path.isdir(secdir):
        raise

    print 'writing boot.properties to %s/servers/%s/security/boot.properties' % (domain_path, server_name)

    bpFile=open('%s/servers/%s/security/boot.properties' % (domain_path, server_name), 'w+')
    bpFile.write("username=%s\n" % adminUsernameEncrypted)
    bpFile.write("password=%s\n" % adminPasswordEncrypted)
    bpFile.close()

    service_name = domain_uid + "-" + server_name

    # Connect to nodemanager and start server
    try:
      nmConnect(admin_username, admin_password, service_name,  '5556', '%DOMAIN_NAME%', '${DOMAIN_HOME}', 'plain')
      nmStart(server_name)
      nmDisconnect()
    except WLSTException, e:
      nmDisconnect()
      print e

    # Update node manager listen address
    if admin_server_url is not None:
      connect(admin_username, admin_password, admin_server_url)
      serverConfig()
      server=cmo.lookupServer(server_name)
      machineName=server.getMachine().getName()
      print 'Name of machine assigned to server %s is %s' % (server_name, machineName)

      if machineName is not None:
        print 'Updating listen address of machine %s' % machineName
        try:
          edit()
          startEdit()
          cd('/')
          machine=cmo.lookupMachine(machineName)
          print 'Machine is %s' % machine
          nm=machine.getNodeManager()
          nm.setListenAddress(service_name)
          nm.setNMType('Plain')
          save()
          activate()
          destroyEditSession("weblogic-operator-%s" % server_name)
          print 'Updated listen address of machine %s to %s' % (machineName, service_name)
        except:
          cancelEdit()
          destroyEditSession("weblogic-operator-%s" % server_name)
          raise

    # Exit WLST
    exit()
    EOF

      checkFileExists ${pyFile}

    }

    # Function to create script for stopping a server
    # \$1 - Domain UID
    # \$2 - Server Name
    function createCommonStopScripts() {

      nmdir=${DOMAIN_HOME}/nodemgr_home
      scriptFile=${nmdir}/stopServer.sh
      pyFile=${nmdir}/stop-server.py

      # Create a script that stops the server.
      # The script and 'EOF' on the following lines must not be indented!
      cat << EOF > ${scriptFile}
    #!/bin/bash

    echo "Stop the server"

    admin_server_t3_url=
    if [ -n "\$3" ]; then
      admin_server_t3_url=t3://\$1-\$3:\$4
    fi

    wlst.sh -skipWLSModuleScanning ${pyFile} \$1 \$2 \$admin_server_t3_url

    # Return status of 2 means failed to stop a server through the NodeManager.
    # Look to see if there is a server process that can be killed.
    if [ \$? -eq 2 ]; then
      pid=\$(jps -v | grep '[D]weblogic.Name=\$2' | awk '{print \$1}')
      if [ ! -z \$pid ]; then
        echo "Killing the server process \$pid"
        kill -15 \$pid
      fi
    fi

    EOF

      checkFileExists ${scriptFile}
      chmod +x ${scriptFile}

      # Create a python script to execute the wlst commands.
      # The script and 'EOF' on the following lines must not be indented!
      cat /u01/weblogic/read-domain-secret.py > ${pyFile}
      cat << EOF >> ${pyFile}

    domain_uid = sys.argv[1]
    server_name = sys.argv[2]
    if (len(sys.argv) == 4):
      admin_server_url = sys.argv[3]
    else:
      admin_server_url = None

    print 'admin_server_url is %s' % admin_server_url

    # Update node manager listen address to None
    if admin_server_url is not None:
      connect(admin_username, admin_password, admin_server_url)
      serverConfig()
      server=cmo.lookupServer(server_name)
      machineName=server.getMachine().getName()
      print 'Name of machine assigned to server %s is %s' % (server_name, machineName)

      if machineName is not None:
        print 'Updating listen address of machine %s' % machineName
        try:
          edit()
          startEdit()
          cd('/')
          machine=cmo.lookupMachine(machineName)
          print 'Machine is %s' % machine
          nm=machine.getNodeManager()
          nm.setListenAddress(None)
          save()
          activate()
          destroyEditSession("weblogic-operator-%s" % server_name)
          print 'Updated listen address of machine %s to None' % machineName
        except:
          cancelEdit()
          destroyEditSession("weblogic-operator-%s" % server_name)

    # Connect to nodemanager and stop server
    try:
      nmConnect(admin_username, admin_password, '\$1-\$2',  '5556', '%DOMAIN_NAME%', '${DOMAIN_HOME}', 'plain')
    except:
      print('Failed to connect to the NodeManager')
      exit(exitcode=2)

    # Kill the server
    try:
      nmKill('\$2')
    except:
      print('Connected to the NodeManager, but failed to stop the server')
      exit(exitcode=2)

    # Exit WLST
    nmDisconnect()
    exit()
    EOF
    }

    checkFileExists ${pyFile}

    # Create the domain
    wlst.sh -skipWLSModuleScanning /u01/weblogic/create-domain.py

    createCommonNodeMgrHome
    createCommonStartScripts
    createCommonStopScripts

    echo "Successfully Completed"

  create-domain.py: |-
    # This python script is used to create a WebLogic domain

    # Read the domain secrets from the common python file
    execfile("/u01/weblogic/read-domain-secret.py")

    server_port        = %MANAGED_SERVER_PORT%
    domain_path        = os.environ.get("DOMAIN_HOME")
    cluster_name       = "%CLUSTER_NAME%"
    number_of_ms       = %NUMBER_OF_MS%
    cluster_type       = "%CLUSTER_TYPE%"

    print('domain_path        : [%s]' % domain_path);
    print('domain_name        : [%DOMAIN_NAME%]');
    print('admin_username     : [%s]' % admin_username);
    print('admin_port         : [%ADMIN_PORT%]');
    print('cluster_name       : [%s]' % cluster_name);
    print('server_port        : [%s]' % server_port);
    print('cluster_type       : [%s]' % cluster_type);

    # Open default domain template
    # ============================
    readTemplate("/u01/oracle/wlserver/common/templates/wls/wls.jar")

    set('Name', '%DOMAIN_NAME%')
    setOption('DomainName', '%DOMAIN_NAME%')
    create('%DOMAIN_NAME%','Log')
    cd('/Log/%DOMAIN_NAME%');
    set('FileName', '/shared/logs/%DOMAIN_NAME%.log')

    # Configure the Administration Server
    # ===================================
    cd('/Servers/AdminServer')
    set('ListenAddress', '%DOMAIN_UID%-%ADMIN_SERVER_NAME%')
    set('ListenPort', %ADMIN_PORT%)
    set('Name', '%ADMIN_SERVER_NAME%')

    create('T3Channel', 'NetworkAccessPoint')
    cd('/Servers/%ADMIN_SERVER_NAME%/NetworkAccessPoints/T3Channel')
    set('PublicPort', %T3_CHANNEL_PORT%)
    set('PublicAddress', '%T3_PUBLIC_ADDRESS%')
    set('ListenAddress', '%DOMAIN_UID%-%ADMIN_SERVER_NAME%')
    set('ListenPort', %T3_CHANNEL_PORT%)

    cd('/Servers/%ADMIN_SERVER_NAME%')
    create('%ADMIN_SERVER_NAME%', 'Log')
    cd('/Servers/%ADMIN_SERVER_NAME%/Log/%ADMIN_SERVER_NAME%')
    set('FileName', '/shared/logs/%ADMIN_SERVER_NAME%.log')

    # Set the admin user's username and password
    # ==========================================
    cd('/Security/%DOMAIN_NAME%/User/weblogic')
    cmo.setName(admin_username)
    cmo.setPassword(admin_password)

    # Write the domain and close the domain template
    # ==============================================
    setOption('OverwriteDomain', 'true')

    # Configure the node manager
    # ==========================
    cd('/NMProperties')
    set('ListenAddress','0.0.0.0')
    set('ListenPort',5556)
    set('CrashRecoveryEnabled', 'true')
    set('NativeVersionEnabled', 'true')
    set('StartScriptEnabled', 'false')
    set('SecureListener', 'false')
    set('LogLevel', 'FINEST')
    set('DomainsDirRemoteSharingEnabled', 'true')

    # Set the Node Manager user name and password (domain name will change after writeDomain)
    cd('/SecurityConfiguration/%DOMAIN_NAME%')
    set('NodeManagerUsername', admin_username)
    set('NodeManagerPasswordEncrypted', admin_password)

    # Configure machines
    # ======================
    if cluster_type == "configured":

      for index in range(0, number_of_ms):

        msIndex = index+1
        machineName = '%DOMAIN_UID%-machine%s' % msIndex
        cd('/')
        create(machineName, 'Machine')
        cd('Machine/%s' % machineName)
        create(machineName, 'NodeManager')
        cd('NodeManager/%s' % machineName)
        set('ListenAddress', '%DOMAIN_UID%-%MANAGED_SERVER_NAME_BASE%%s' % msIndex)
        set('NMType', 'Plain')

    # Create a cluster
    cd('/')
    cl=create(cluster_name, 'Cluster')

    if cluster_type == "configured":

      # Create managed servers
      for index in range(0, number_of_ms):
        cd('/')

        msIndex = index+1
        name = '%MANAGED_SERVER_NAME_BASE%%s' % msIndex
        machineName = '%DOMAIN_UID%-machine%s' % msIndex

        create(name, 'Server')
        cd('/Servers/%s/' % name )
        print('managed server name is %s' % name);
        set('ListenAddress', '%DOMAIN_UID%-%s' % name)
        set('ListenPort', server_port)
        set('NumOfRetriesBeforeMSIMode', 0)
        set('RetryIntervalBeforeMSIMode', 1)
        set('Cluster', cluster_name)
        set('Machine', machineName)

        create(name,'Log')
        cd('/Servers/%s/Log/%s' % (name, name))
        set('FileName', '/shared/logs/%s.log' % name)
    else:
      print('Configuring Dynamic Cluster %s' % cluster_name)

      templateName = cluster_name + "-template"
      print('Creating Server Template: %s' % templateName)
      st1=create(templateName, 'ServerTemplate')
      print('Done creating Server Template: %s' % templateName)
      cd('/ServerTemplates/%s' % templateName)
      cmo.setListenPort(server_port)
      cmo.setListenAddress('%DOMAIN_UID%-%MANAGED_SERVER_NAME_BASE%${id}')
      cmo.setCluster(cl)
      print('Done setting attributes for Server Template: %s' % templateName);


      cd('/Clusters/%s' % cluster_name)
      create(cluster_name, 'DynamicServers')
      cd('DynamicServers/%s' % cluster_name)
      set('ServerTemplate', st1)
      set('ServerNamePrefix', "%MANAGED_SERVER_NAME_BASE%")
      set('DynamicClusterSize', number_of_ms)
      set('MaxDynamicClusterSize', 800)
      set('CalculatedMachineNames', true)
      set('CalculatedListenPorts', false)
      machineNameExpression = '%DOMAIN_UID%-%s-machine*' % cluster_name
      set('MachineNameMatchExpression', machineNameExpression)
      set('Id', 1)

      print('Done setting attributes for Dynamic Cluster: %s' % cluster_name);

    # Write Domain
    # ============
    writeDomain(domain_path)
    closeTemplate()
    print 'Domain Created'

    # Update Domain
    readDomain(domain_path)
    cd('/')
    cmo.setProductionModeEnabled(%PRODUCTION_MODE_ENABLED%)
    updateDomain()
    closeDomain()
    print 'Domain Updated'
    print 'Done'

    # Exit WLST
    # =========
    exit()

---
apiVersion: batch/v1
kind: Job
metadata:
  name: domain-%DOMAIN_UID%-job
  namespace: %NAMESPACE%
spec:
  template:
    metadata:
      labels:
        app: domain-%DOMAIN_UID%-job
        weblogic.domainUID: %DOMAIN_UID%
    spec:
      restartPolicy: Never
      containers:
        - name: domain-job
          image: store/oracle/weblogic:12.2.1.3
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 7001
          volumeMounts:
          - mountPath: /u01/weblogic
            name: config-map-scripts
          - mountPath: /shared
            name: pv-storage
          - mountPath: /weblogic-operator/secrets
            name: secrets
          command: ["/bin/sh"]
          args: ["/u01/weblogic/create-domain-job.sh"]
          env:
            - name: SHARED_PATH
              value: "/shared"
      volumes:
        - name: config-map-scripts
          configMap:
            name: domain-%DOMAIN_UID%-scripts
        - name: pv-storage
          persistentVolumeClaim:
            claimName: %PERSISTENT_VOLUME_CLAIM%
        - name: secrets
          secret:
            secretName: %SECRET_NAME%
      %IMAGE_PULL_SECRET_PREFIX%imagePullSecrets:
      %IMAGE_PULL_SECRET_PREFIX%- name: %DOCKER_REGISTRY_SECRET%
